#!/usr/bin/env python

"""Convert binary data into a human friendly format.

Will run selftest when executed as a script.

Copyright (c) 2025 N. Dornseif

Licensed under the MIT license
<LICENSE or https://opensource.org/licenses/MIT>.
This file may not be copied, modified, or distributed
except according to those terms.
"""

type BytesLike = bytes | bytearray

# fmt: off
# Pricklybird wordlist mapping each byte value to a word.
WORDLIST  = [
    "acid", "also", "anti", "arch", "area", "atom", "aunt", "baby", "back",
    "ball", "bang", "bare", "barn", "beef", "beep", "beer", "best", "beta",
    "blob", "blow", "boom", "boss", "bush", "call", "calm", "card", "cars",
    "cash", "clay", "coma", "cook", "core", "crab", "crop", "damp", "dark",
    "dash", "data", "dawn", "deaf", "deal", "deer", "deny", "dice", "disc",
    "dogs", "draw", "drug", "drum", "dust", "east", "easy", "eggs", "else",
    "epic", "etch", "ever", "evil", "exam", "face", "fact", "fawn", "film",
    "fish", "flag", "flaw", "flea", "flux", "food", "four", "full", "funk",
    "fury", "fuzz", "gain", "game", "gang", "gasp", "gear", "germ", "gift",
    "girl", "glow", "gold", "grab", "guts", "hair", "half", "hand", "harm",
    "hazy", "help", "herb", "hero", "high", "hill", "hiss", "horn", "hurt",
    "husk", "hype", "icon", "idea", "idle", "indy", "info", "iris", "itch",
    "item", "jade", "jail", "jaws", "join", "jump", "jury", "just", "kale",
    "keen", "keto", "kick", "king", "kiss", "kiwi", "knob", "lady", "lake",
    "lamp", "last", "leaf", "lens", "liar", "lion", "logo", "long", "lord",
    "luck", "lush", "mage", "mail", "many", "mars", "math", "memo", "menu",
    "meta", "mild", "mini", "moon", "must", "nail", "name", "navy", "neck",
    "need", "next", "noon", "norm", "nuts", "oath", "once", "orca", "oval",
    "over", "page", "paid", "palm", "path", "pawn", "ping", "pins", "play",
    "pool", "poor", "port", "puff", "pump", "quit", "race", "raid", "rain",
    "ramp", "rash", "rats", "rear", "redo", "reef", "ring", "risk", "room",
    "ruby", "rust", "safe", "sail", "salt", "sand", "scar", "ship", "sick",
    "sign", "sing", "slab", "slow", "soda", "solo", "stay", "surf", "swim",
    "taco", "talk", "taxi", "team", "tech", "text", "tiny", "tips", "toad",
    "tofu", "tomb", "tool", "tour", "trap", "tuna", "turf", "twig", "twin",
    "type", "ugly", "undo", "urge", "user", "very", "veto", "vial", "visa",
    "void", "volt", "vote", "walk", "wall", "warn", "warp", "wash", "wear",
    "west", "wind", "wing", "wire", "wolf", "worm", "yank", "yard", "yeah",
    "yell", "yoga", "zeus", "zone",
]
# fmt: on


def word_hash(word_first_letter: str, word_last_letter: str) -> int:
    """Perfect hash function to index the `HASH_TABLE`.

    Utilizes the fact that all words in the wordlist have unique first,
     last letter pairs.

    # Usage
    >>> word = "turf"
    >>> word_hash(word[0], word[-1])
    149
    """
    first_letter_index = ord(word_first_letter[0])
    last_letter_index = ord(word_last_letter[0])
    if not (ord("a") <= first_letter_index <= ord("z")):
        return 0
    if not (ord("a") <= last_letter_index <= ord("z")):
        return 0
    return (first_letter_index - ord("a")) + (last_letter_index - ord("a")) * 26


# The highest hash value generated by `word_hash` is 656 for words in the wordlist,
# but with incorrect input where the first and last letter are `z`,
# the value might reach 26 ** 2 - 1 = 675.
# So we make the table 676 entries long to prevent out of bounds errors.
HASH_TABLE_SIZE = 676


def _generate_hashtable(wordlist: list[str]) -> list[int]:
    """Prepare word to byte hashtable.

    Generate hash table by calculating hash for every word and populating
    the hash table position with that words byte value.
    """
    result = [0] * HASH_TABLE_SIZE
    for i, word in enumerate(wordlist):
        result[word_hash(word[0], word[-1])] = i
    return result


# Hash table indexed by giving the `word_hash` function the words first and last letter.
# Contains the matching byte value.
HASH_TABLE = _generate_hashtable(WORDLIST)

# Polynominal used in CRC-8 calculation.
CRC8_POLY = 0x1D

# Number of different possible values in a byte.
_N_BYTES = 256


def _generate_crc_table(polynominal: int) -> list[int]:
    """Precomputes `CRC8_TABLE` to speed up CRC-8 calculations."""
    table = [0] * _N_BYTES
    for i in range(_N_BYTES):
        crc = i
        for _ in range(8):
            if crc & 0x80:
                crc = (crc << 1) ^ polynominal
            else:
                crc <<= 1
            crc &= 0xFF
        table[i] = crc
    return table


# Table of CRC8 values for all possible bytes, allows fast calculation of CRC.
CRC8_TABLE = _generate_crc_table(CRC8_POLY)


class DecodeError(Exception):
    """Unable to decode pricklybird words."""


class CRCError(DecodeError):
    """Invalid CRC detected while decoding."""


def calculate_crc8(data: BytesLike) -> bytes:
    """Calculate the CRC-8 used by pricklybird based on a precomputed table.

    # CRC parameters
    - Output width of 8 bits
    - Division using the polynomial `0x1D`
    - An initial value of zero
    - No input or output reflection
    - No XOR operation on the output
    - Remainder after division of data with correct CRC appended is zero

    # Usage
    >>> from pricklybird import calculate_crc8
    >>> data = bytearray()
    >>> data.extend("123456789".encode())
    >>> calculate_crc8(data).hex()
    '37'
    """
    crc = 0

    for byte in data:
        crc = CRC8_TABLE[(crc ^ byte)]
    return crc.to_bytes(1)


def bytes_to_words(data: BytesLike) -> list[str]:
    """Convert bytearray to list of pricklybird words.

    Return a list of words with each input byte mapped to the matching pricklybird word.

    # Usage
    >>> from pricklybird import bytes_to_words
    >>> data = bytearray.fromhex("4243")
    >>> bytes_to_words(data)
    ['flea', 'flux']
    """
    return [WORDLIST[int(b)] for b in data]


def convert_to_pricklybird(data: BytesLike) -> str:
    """Convert arbitrary data to pricklybird words and attach CRC.

    # Usage
    >>> from pricklybird import convert_to_pricklybird
    >>> data = bytearray.fromhex("4243")
    >>> convert_to_pricklybird(data)
    'flea-flux-full'
    """
    if not data:
        return ""
    return "-".join(bytes_to_words(data + calculate_crc8(data)))


def words_to_bytes(words: list[str]) -> bytearray:
    """Map a list of pricklybird words to their coresponding bytes.

    # Errors
    Will raise `DecodeError` if:
    - The input contains non ASCII compatible characters
    - The words in the input are not all four characters long
    - Words in the input dont appear in the wordlist

    # Usage
    >>> from pricklybird import words_to_bytes
    >>> words_to_bytes(["flea", "flux"]).hex()
    '4243'
    """
    data = bytearray(len(words))
    for i, word in enumerate(words):
        if not word.isascii():
            raise DecodeError("Input must only contain ASCII compatible UTF-8.")
        if len(word) != 4:
            raise DecodeError("Input words must be four characters long.")

        word_lower = word.lower()
        index = HASH_TABLE[word_hash(word_lower[0], word_lower[-1])]
        if WORDLIST[index] != word_lower:
            raise DecodeError("Invalid word detected in input.")
        data[i] = index
    return data


def convert_from_pricklybird(words: str) -> bytearray:
    """Convert pricklybird words to bytearray and check CRC.

    # Errors
    Will raise `DecodeError` if:
    - The input is less than two words long,
    - The input contains non ASCII compatible characters
    - The words in the input are not all four characters long
    - Words in the input dont appear in the wordlist

    Will raise `CRCError` if the CRC value does not match the input.

    # Usage
    >>> from pricklybird import convert_from_pricklybird
    >>> convert_from_pricklybird("flea-flux-full").hex()
    '4243'
    """
    word_list = words.strip().split("-")
    if len(word_list) < 2:  # Need at least data + CRC
        raise DecodeError("Input must be at least two words long.")

    data = words_to_bytes(word_list)
    if calculate_crc8(data) != b"\x00":
        raise CRCError("Invalid CRC while decoding words.")
    return data[:-1]


if __name__ == "__main__":
    import doctest
    import unittest

    class PricklybirdTests(unittest.TestCase):
        """Test the conversion from and to pricklybird."""

        TEST_DATA_SEED = 1
        test_data = bytearray()

        @classmethod
        def generate_test_data(cls, seed: int) -> bytearray:
            """Generate pseudorandom test data using the Lehmer64 LCG."""
            output_bytes = 4096
            warmup_iterations = 128
            state = seed & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
            multiplier = 0xDA942042E4DD58B5
            # Mix up the state a little to compensate for potentialy small seed.
            for _ in range(warmup_iterations):
                state = (state * multiplier) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF

            result = bytearray(output_bytes)
            for i in range(0, output_bytes, 8):
                state = (state * multiplier) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
                random_val = (state >> 64) & 0xFFFFFFFFFFFFFFFF
                result[i : i + 8] = random_val.to_bytes(8, "little")
            return result

        @classmethod
        def setUpClass(cls) -> None:
            """Generate test data using pseudorandom function."""
            if not cls.test_data:
                cls.test_data = cls.generate_test_data(cls.TEST_DATA_SEED)

        def test_vectors(self) -> None:
            """Test the standard vectors supplied with the specification."""
            test_vectors = [
                (bytearray.fromhex("DEADBEEF"), "turf-port-rust-warn-void"),
                (bytearray.fromhex("4243"), "flea-flux-full"),
                (bytearray.fromhex("1234567890"), "blob-eggs-hair-king-meta-yell"),
                (bytearray.fromhex("0000000000"), "acid-acid-acid-acid-acid-acid"),
                (bytearray.fromhex("ffffffffff"), "zone-zone-zone-zone-zone-sand"),
            ]

            for data, words in test_vectors:
                with self.subTest(
                    msg=f"Failed to convert {data} test vector to pricklybird."
                ):
                    self.assertEqual(words, convert_to_pricklybird(data))
                with self.subTest(
                    msg=f"Failed to convert {words} test vector to bytes."
                ):
                    self.assertEqual(data, convert_from_pricklybird(words))

        def test_simple_conversion(self) -> None:
            """Test conversion to and from pricklybird on pseudorandom test data."""
            coded_words = convert_to_pricklybird(self.test_data)
            self.assertEqual(
                self.test_data,
                convert_from_pricklybird(coded_words),
                "Converter did not correctly endcode or decode data.",
            )

        def test_uppercase(self) -> None:
            """Test that pricklybird input containing mixed case is properly decoded."""
            self.assertEqual(
                bytearray.fromhex("DEADBEEF"),
                convert_from_pricklybird("TUrF-Port-RUST-warn-vOid"),
                msg="Converter did not correctly decode upercase data.",
            )

        def test_error_detection_bit_flip(self) -> None:
            """Test that replacing a pricklybird word is detected using the CRC-8."""
            coded_words = convert_to_pricklybird(self.test_data)
            corrupted_test_data = self.test_data.copy()
            # Flip bit in first word
            corrupted_test_data[0] ^= 1
            incorrect_word = bytes_to_words(corrupted_test_data[0:1])[0]

            # Replace fist word with incorrect one
            corrupted_words = incorrect_word[:4] + coded_words[4:]
            with self.assertRaises(
                CRCError, msg="Converter did not detect error in corrupted input."
            ):
                convert_from_pricklybird(corrupted_words)

        def test_error_detection_adjacent_swap(self) -> None:
            """Check that swapping two adjacent words is detected using the CRC-8."""
            coded_words = convert_to_pricklybird(self.test_data)
            word_list = coded_words.split("-")
            word_list[0], word_list[1] = word_list[1], word_list[0]
            swapped_coded_words = "-".join(word_list)
            with self.assertRaises(
                CRCError, msg="Converter did not detect error caused by word swap."
            ):
                convert_from_pricklybird(swapped_coded_words)

        def test_whitespace_trim(self) -> None:
            """Check that whitespace is correctly trimmed."""
            self.assertEqual(
                bytearray.fromhex("4243"),
                convert_from_pricklybird(
                    " \t\n\r\x0b\x0c flea-flux-full \t\n\r\x0b\x0c "
                ),
            )

        def test_unusual_input(self) -> None:
            """Check that edge cases result in the correct errors."""
            test_cases = [
                ("", "Converter did not error with empty input"),
                ("orca", "Converter did not error with to short input"),
                ("a®¿a-orca", "Converter did not error with non ascii input"),
                (
                    "gäsp-risk-king-orca-husk",
                    "Converter did not error with non ascii input",
                ),
                (
                    "-risk-king-orca-husk",
                    "Converter did not error with incorrectly formatted input",
                ),
                (
                    "gasp-rock-king-orca-husk",
                    "Converter did not error with incorrect word in input",
                ),
                (
                    "flea- \t \t-full",
                    "Converter did not error with whitespace in input",
                ),
                ("flea-aaa\0-full", "Converter did not error with null bytes in input"),
                ("flea-\0aaa-full", "Converter did not error with null bytes in input"),
                (
                    "flea-\x7faaa-full",
                    "Converter did not error with ASCII control character in input",
                ),
                (
                    "flea-aaa\x7f-full",
                    "Converter did not error with ASCII control character in input",
                ),
                # Check that no index out of bound error is thrown when the highest
                # possible value is used to index the hash table.
                ("zzzz-king", "Converter did not error with incorrect word in input"),
            ]
            for input_words, msg in test_cases:
                with (
                    self.subTest(msg=f"{msg} ({input_words})."),
                    self.assertRaises(DecodeError),
                ):
                    convert_from_pricklybird(input_words)

        def test_empty_input(self) -> None:
            """Check that empty input results in empty output."""
            self.assertEqual("", convert_to_pricklybird(bytearray()))
            self.assertEqual([], bytes_to_words(bytearray()))
            self.assertEqual(bytearray(), words_to_bytes([]))

    class CRC8Tests(unittest.TestCase):
        """Check functionality of the cyclic redundancy check."""

        def test_empty_input(self) -> None:
            """Check that CRC-8 of empty input is zero."""
            self.assertEqual(
                b"\x00", calculate_crc8(bytearray()), "CRC-8 of empty data should be 0."
            )

        def test_table_lookup(self) -> None:
            """Check that CRC-8 of a byte is equal to the matching table value."""
            test_data = bytearray([0x42])
            result = calculate_crc8(test_data)[0]
            expected = CRC8_TABLE[test_data[0]]
            self.assertEqual(
                expected, result, "CRC-8 of single byte should match table value."
            )

        def test_with_appended_crc(self) -> None:
            """Check that data with appended correct CRC-8 has a remainder of zero."""
            test_data = bytearray(b"Test data")
            test_data.extend(calculate_crc8(test_data))
            self.assertEqual(
                b"\x00",
                calculate_crc8(test_data),
                "Data with appended correct CRC-8 should result in remainder 0.",
            )

    doctest.testmod(verbose=True)
    unittest.main(verbosity=2)
